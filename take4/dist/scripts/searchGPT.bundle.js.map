{"version":3,"file":"scripts/searchGPT.bundle.js","mappings":"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;;;;;;;;AC9F5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqG;;;;;;;UCxLrG;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA,8CAA8C;;;;;WCA9C;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WA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","sources":["webpack://chrome-extension-boilerplate/./src/client.ts","webpack://chrome-extension-boilerplate/./node_modules/idb/build/index.js","webpack://chrome-extension-boilerplate/./node_modules/idb/build/wrap-idb-value.js","webpack://chrome-extension-boilerplate/webpack/bootstrap","webpack://chrome-extension-boilerplate/webpack/runtime/define property getters","webpack://chrome-extension-boilerplate/webpack/runtime/hasOwnProperty shorthand","webpack://chrome-extension-boilerplate/webpack/runtime/make namespace object","webpack://chrome-extension-boilerplate/./src/scripts/searchGPT/index.ts"],"sourcesContent":["import { BrokerEvent, EventCallback } from \"./types\";\n\nexport class BrokerClient<T extends string, P> {\n  port: chrome.runtime.Port;\n  eventListeners: Map<string, Set<EventCallback<T, P>>>;\n\n  constructor() {\n    this.port = chrome.runtime.connect({ name: `${Math.random()}` });\n    this.eventListeners = new Map();\n    this.port.onMessage.addListener(this.handleMessage.bind(this));\n  }\n\n  handleMessage(event: BrokerEvent<T, P>): void {\n    // Process non-wildcard events\n    if (event.type !== \"*\") {\n      const callbacks = this.eventListeners.get(event.type);\n      if (callbacks) {\n        for (const callback of callbacks) {\n          callback(event);\n        }\n      }\n    }\n\n    // Process wildcard events\n    const wildcardCallbacks = this.eventListeners.get(\"*\");\n    if (wildcardCallbacks) {\n      for (const callback of wildcardCallbacks) {\n        callback(event);\n      }\n    }\n  }\n\n  connect(): void {\n    this.port.postMessage({ type: \"SUBSCRIBE\", payload: \"*\" });\n  }\n\n  disconnect(): void {\n    this.port.postMessage({ type: \"UNSUBSCRIBE\", payload: \"*\" });\n    this.port.disconnect();\n  }\n\n  on(eventType: string, callback: EventCallback<T, P>): void {\n    if (!this.eventListeners.has(eventType)) {\n      this.eventListeners.set(eventType, new Set());\n    }\n    this.eventListeners.get(eventType)?.add(callback);\n    this.port.postMessage({ type: \"SUBSCRIBE\", payload: eventType });\n  }\n\n  off(eventType: string, callback: EventCallback<T, P>): void {\n    const callbacks = this.eventListeners.get(eventType);\n    if (callbacks) {\n      callbacks.delete(callback);\n      if (callbacks.size === 0) {\n        this.port.postMessage({ type: \"UNSUBSCRIBE\", payload: eventType });\n      }\n    }\n  }\n\n  dispatch(event: BrokerEvent<T, P>): void {\n    this.port.postMessage(event);\n  }\n}\n\nexport default BrokerClient;\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { BrokerClient } from \"../../client\";\nimport { openDB, IDBPDatabase } from \"idb\";\n\ntype ConversationItem = {\n  id: string;\n  title: string;\n  create_time: string;\n  update_time: string;\n};\n\ntype Conversation = {\n  id: string;\n  title: string;\n  create_time: number;\n  update_time: number;\n  mapping: any;\n};\n\nclass Deferred {\n  promise: Promise<void>;\n  resolve: (() => void) | undefined;\n  reject: (() => void) | undefined;\n\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n\nclass DBJobQueue {\n  private queue: (() => Promise<void>)[] = [];\n  private isRunning: boolean = false;\n  private deferred: Deferred | undefined;\n\n  async addJob(job: () => Promise<void>) {\n    this.queue.push(job);\n    if (!this.isRunning) {\n      this.isRunning = true;\n      await this.processQueue();\n      this.isRunning = false;\n    } else {\n      await this.deferred?.promise;\n    }\n  }\n\n  private async processQueue() {\n    this.deferred = new Deferred();\n    while (this.queue.length > 0) {\n      const job = this.queue.shift();\n      // console.log(\"job\", job);\n      if (job) {\n        await job();\n      }\n      // console.log(\"job done\");\n    }\n    this.deferred.resolve && this.deferred.resolve();\n  }\n}\n\nclass GPTDatabase {\n  private dbPromise: Promise<IDBPDatabase> | undefined;\n  private DB_NAME = \"gpt\";\n  private DB_VERSION = 1;\n  private META_STORE = \"meta\";\n  private jobQueue: DBJobQueue;\n\n  constructor() {\n    this.init();\n    this.jobQueue = new DBJobQueue();\n  }\n\n  private async closeDB(db: IDBPDatabase): Promise<void> {\n    db.close();\n    await new Promise((resolve) => setTimeout(resolve, 5000));\n  }\n\n  private async openDB(\n    name: string,\n    version: number,\n    onUpgradeNeeded: (\n      db: IDBPDatabase,\n      oldVersion: number,\n      newVersion: number\n    ) => void\n  ) {\n    return await openDB(name, version, {\n      upgrade(db, oldVersion, newVersion) {\n        onUpgradeNeeded(db, oldVersion, newVersion as number);\n      },\n    });\n  }\n\n  async init() {\n    const storedVersion = parseInt(localStorage.getItem(\"db_version\") || \"1\");\n    this.DB_VERSION = storedVersion;\n    this.dbPromise = this.openDB(\n      this.DB_NAME,\n      this.DB_VERSION,\n      (db, oldVersion, newVersion) => {\n        if (oldVersion < 1) {\n          const indexStore = db.createObjectStore(this.META_STORE, {\n            keyPath: \"id\",\n          });\n          // Index by title\n          indexStore.createIndex(\"title\", \"title\");\n\n          // Index by create_time\n          indexStore.createIndex(\"create_time\", \"create_time\");\n\n          // Index by update_time\n          indexStore.createIndex(\"update_time\", \"update_time\");\n        }\n        // Additional upgrades can be handled here\n      }\n    );\n  }\n\n  async upgradeDB(createStoreName: string) {\n    if (this.dbPromise) {\n      const db = await this.dbPromise;\n      console.log(\"got db\");\n      await this.closeDB(db);\n      console.log(\"closed db\");\n    }\n\n    this.DB_VERSION += 1;\n    localStorage.setItem(\"db_version\", this.DB_VERSION.toString());\n    this.dbPromise = this.openDB(\n      this.DB_NAME,\n      this.DB_VERSION,\n      (db, oldVersion, newVersion) => {\n        console.log(\"creating store\", createStoreName);\n        if (!db.objectStoreNames.contains(createStoreName)) {\n          db.createObjectStore(createStoreName, { keyPath: \"id\" });\n        }\n      }\n    );\n  }\n\n  async addConversationItems(items: ConversationItem[]) {\n    await this.jobQueue.addJob(async () => {\n      try {\n        const db = await this.dbPromise;\n        const tx = db!.transaction(this.META_STORE, \"readwrite\");\n        const indexStore = tx.objectStore(this.META_STORE);\n\n        for (const item of items) {\n          await indexStore.put(item);\n        }\n\n        await tx.done;\n      } catch (error) {\n        console.warn(\"Error in addConversationItems transaction:\", error);\n      }\n    });\n  }\n\n  async createConversationStore(id: string, conversation: any) {\n    const { title, create_time, update_time, mapping } = conversation;\n\n    await this.jobQueue.addJob(async () => {\n      const db = await this.dbPromise;\n\n      if (!db!.objectStoreNames.contains(id)) {\n        console.log(\"creating store\", id);\n        await this.upgradeDB(id);\n        console.log(\"store created1\", id);\n      }\n    });\n\n    await this.jobQueue.addJob(async () => {\n      const db = await this.dbPromise;\n      console.log(\"store created2\", id);\n\n      const tx = db!.transaction(id, \"readwrite\");\n      const conversationStore = tx.objectStore(id);\n\n      const indexObj = { id, title, create_time, update_time };\n      console.log(\"putting index\", indexObj);\n      await conversationStore.put(indexObj);\n      for (const key in mapping) {\n        const obj = mapping[key];\n        await conversationStore.put(obj);\n      }\n      console.log(\"putting index done\");\n      await tx.done;\n    });\n  }\n\n  async scan(): Promise<string | null> {\n    return new Promise((resolve, reject) => {\n      this.jobQueue.addJob(async () => {\n        // alert(\"scan start\");\n        const db = await this.dbPromise;\n        const tx = db!.transaction(this.META_STORE, \"readonly\");\n        const indexStore = tx.objectStore(this.META_STORE);\n        let cursor = await indexStore.openCursor();\n\n        const promises = [];\n\n        while (cursor) {\n          const { value } = cursor;\n\n          cursor = await cursor.continue();\n          // console.log(\"checking\", value.id, \"...\");\n          promises.push(\n            (async () => {\n              try {\n                const conversationStoreTx = db!.transaction(\n                  value.id,\n                  \"readonly\"\n                );\n                const conversationStore = conversationStoreTx.objectStore(\n                  value.id\n                );\n                const indexObj = await conversationStore.get(value.id);\n\n                if (indexObj) {\n                  // Convert Unix timestamp to milliseconds\n                  const indexUpdateTime = new Date(\n                    indexObj.update_time * 1000\n                  ).getTime();\n\n                  // Create a Date object using the UTC timestamp\n                  const valueUpdateTime = new Date(value.update_time).getTime();\n\n                  // Calculate the timezone offset in milliseconds\n                  const timezoneOffset =\n                    new Date().getTimezoneOffset() * 60 * 1000;\n\n                  // Adjust the valueUpdateTime for the timezone offset\n                  const valueUpdateTimeAdjusted =\n                    valueUpdateTime - timezoneOffset;\n\n                  // Calculate the absolute time difference\n                  const timeDifference = Math.abs(\n                    indexUpdateTime - valueUpdateTimeAdjusted\n                  );\n\n                  if (timeDifference > 1000) {\n                    console.log(\n                      \"found difference\",\n                      value.id,\n                      indexUpdateTime,\n                      valueUpdateTimeAdjusted,\n                      timeDifference\n                    );\n                    resolve(value.id);\n                    return;\n                  }\n                } else {\n                  console.log(\"found missing\", value.id);\n                  resolve(value.id);\n                  return;\n                }\n              } catch (e) {\n                console.log(\"found missing\", value.id);\n                resolve(value.id);\n                return;\n              }\n            })()\n          );\n        }\n\n        await Promise.all(promises);\n\n        resolve(null);\n        return;\n      });\n    });\n  }\n\n  async searchConversation(\n    conversationId: string,\n    searchTerm: string\n  ): Promise<{ conversationId: string; matches: Set<string> } | null> {\n    try {\n      const db = await this.dbPromise;\n\n      if (!db!.objectStoreNames.contains(conversationId)) {\n        return null;\n      }\n\n      const tx = db!.transaction(conversationId, \"readonly\");\n      const conversationStore = tx.objectStore(conversationId);\n      let cursor = await conversationStore.openCursor();\n      const matches: Set<string> = new Set();\n      const rval = { conversationId, matches, title: \"\" };\n\n      while (cursor) {\n        const value = cursor.value;\n\n        if (value.title) {\n          rval.title = value.title;\n        }\n\n        if (\n          value.message &&\n          value.message.content &&\n          value.message.content.parts\n        ) {\n          for (const part of value.message.content.parts) {\n            if (part.toLowerCase().includes(searchTerm.toLowerCase())) {\n              matches.add(part);\n            }\n          }\n        }\n\n        cursor = await cursor.continue();\n      }\n\n      if (matches.size > 0) {\n        return rval;\n      } else {\n        return null;\n      }\n    } catch (error) {\n      console.warn(\"Error while searching conversation:\", error);\n      throw error;\n    }\n  }\n\n  async search(\n    searchTerm: string\n  ): Promise<\n    Array<{ conversationId: string; matches: Set<string>; title: string }>\n  > {\n    return new Promise(async (resolve, reject) => {\n      this.jobQueue.addJob(async () => {\n        try {\n          const db = await this.dbPromise;\n          const tx = db!.transaction(this.META_STORE, \"readonly\");\n          const indexStore = tx.objectStore(this.META_STORE);\n          let cursor = await indexStore.openCursor();\n\n          const searchPromises: Promise<{\n            conversationId: string;\n            matches: Set<string>;\n          } | null>[] = [];\n\n          while (cursor) {\n            const value = cursor.value;\n            const conversationId = value.id;\n            searchPromises.push(\n              this.searchConversation(conversationId, searchTerm)\n            );\n            cursor = await cursor.continue();\n          }\n\n          const results = await Promise.all(searchPromises);\n          const filteredResults = results.filter(\n            (result) => result !== null\n          ) as Array<{\n            conversationId: string;\n            matches: Set<string>;\n            title: string;\n          }>;\n\n          resolve(filteredResults);\n        } catch (error) {\n          console.warn(\"Error while searching:\", error);\n          reject(error);\n        }\n      });\n    });\n  }\n}\n\nfunction findClosestScrollableParent(element: HTMLElement): HTMLElement | null {\n  let currentElement: HTMLElement | null = element;\n\n  while (currentElement) {\n    const overflowY = window.getComputedStyle(currentElement).overflowY;\n    if (overflowY === \"scroll\" || overflowY === \"auto\") {\n      return currentElement;\n    }\n    currentElement = currentElement.parentElement;\n  }\n\n  return null;\n}\n\nfunction debounce(\n  func: (...args: any[]) => void,\n  wait: number\n): (...args: any[]) => void {\n  let timeout: number | undefined;\n\n  return function (...args: any[]): void {\n    const later = () => {\n      timeout = undefined;\n      func(...args);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait) as unknown as number;\n  };\n}\n\ninterface TooltipWithInfo extends HTMLElement {\n  matchingElement: HTMLElement;\n  updateTooltipPosition: () => void;\n}\n\nfunction setupSearchBox(gptDatabase: GPTDatabase): void {\n  const searchBox = document.createElement(\"input\");\n  searchBox.type = \"text\";\n  searchBox.placeholder = \"Search...\";\n  searchBox.style.position = \"fixed\";\n  searchBox.style.top = \"10px\";\n  searchBox.style.right = \"10px\";\n  searchBox.style.border = \"1px solid #ccc\";\n  searchBox.style.borderRadius = \"3px\";\n  searchBox.style.padding = \"5px\";\n  searchBox.style.fontSize = \"14px\";\n  searchBox.style.color = \"black\";\n  setTimeout(() => document.body.appendChild(searchBox), 100);\n\n  let activeTooltips: TooltipWithInfo[] = [];\n\n  function clearTooltips() {\n    for (const tooltip of activeTooltips) {\n      const scrollableParent = findClosestScrollableParent(\n        tooltip.matchingElement\n      );\n      if (scrollableParent) {\n        scrollableParent.removeEventListener(\n          \"scroll\",\n          tooltip.updateTooltipPosition\n        );\n      }\n      tooltip.remove();\n    }\n    activeTooltips = [];\n  }\n\n  const debouncedSearch = debounce(async (event: Event) => {\n    clearTooltips();\n\n    const searchTerm = (event.target as HTMLInputElement).value;\n\n    if (searchTerm.length < 4) {\n      return;\n    }\n\n    const results = await gptDatabase.search(searchTerm);\n\n    for (const result of results) {\n      const matchingElements = Array.from(\n        document.querySelectorAll(\"div\")\n      ).filter((element) => element.innerText === result.title);\n\n      for (const element of matchingElements) {\n        const tooltip = document.createElement(\n          \"div\"\n        ) as unknown as TooltipWithInfo;\n        tooltip.matchingElement = element;\n\n        const scrollableParent = findClosestScrollableParent(element);\n        if (scrollableParent) {\n          scrollableParent.addEventListener(\"scroll\", updateTooltipPosition);\n        }\n        function updateTooltipPosition() {\n          const parentRect = scrollableParent!.getBoundingClientRect();\n          const elementRect = element.getBoundingClientRect();\n          tooltip.style.left = `${parentRect.right + 5}px`;\n          tooltip.style.top = `${elementRect.top}px`;\n        }\n\n        tooltip.updateTooltipPosition = updateTooltipPosition;\n\n        tooltip.style.position = \"fixed\";\n        tooltip.style.zIndex = \"10\";\n        tooltip.style.backgroundColor = \"rgba(0, 0, 0, 0.7)\";\n        tooltip.style.color = \"white\";\n        tooltip.style.borderRadius = \"3px\";\n        tooltip.style.padding = \"5px\";\n        tooltip.style.fontSize = \"12px\";\n        tooltip.style.maxWidth = \"500px\";\n        tooltip.style.boxShadow = \"0 4px 6px rgba(0, 0, 0, 0.1)\";\n        // Add a left-pointing nub\n        const nub = document.createElement(\"div\");\n        nub.style.position = \"absolute\";\n        nub.style.width = \"0\";\n        nub.style.height = \"0\";\n        nub.style.borderTop = \"6px solid transparent\";\n        nub.style.borderBottom = \"6px solid transparent\";\n        nub.style.borderLeft = \"6px solid white\";\n        nub.style.top = \"10px\";\n        nub.style.right = \"-6px\";\n        tooltip.appendChild(nub);\n\n        // Bring the tooltip to the front when hovered\n        tooltip.addEventListener(\"mouseenter\", () => {\n          tooltip.style.zIndex = \"1000\";\n        });\n\n        tooltip.addEventListener(\"mouseleave\", () => {\n          tooltip.style.zIndex = \"10\";\n        });\n\n        tooltip.matchingElement = element;\n        tooltip.updateTooltipPosition = updateTooltipPosition;\n\n        updateTooltipPosition();\n\n        tooltip.innerHTML = Array.from(result.matches)\n          .map((match) => {\n            const firstOccurrenceIndex = match\n              .toLowerCase()\n              .indexOf(searchTerm.toLowerCase());\n            const start = Math.max(0, firstOccurrenceIndex - 25);\n            const end = Math.min(\n              match.length,\n              firstOccurrenceIndex + searchTerm.length + 25\n            );\n            const truncatedMatch = `...${match.slice(start, end)}...`;\n            return truncatedMatch.replace(\n              new RegExp(`(${searchTerm})`, \"gi\"),\n              '<mark style=\"background-color: yellow;\">$1</mark>'\n            );\n          })\n          .join(\"<br>\");\n\n        const wrapper = document.createElement(\"div\");\n        wrapper.style.position = \"relative\";\n        wrapper.style.display = \"inline-block\";\n        element.parentNode!.insertBefore(wrapper, element);\n        wrapper.appendChild(element);\n        wrapper.appendChild(tooltip);\n        activeTooltips.push(tooltip);\n      }\n    }\n  }, 1000);\n\n  searchBox.addEventListener(\"input\", debouncedSearch);\n}\n\n(async () => {\n  const client = new BrokerClient();\n  const db = new GPTDatabase();\n  // alert(\"db created\");\n  setupSearchBox(db);\n  if (window.location.hash === \"#scan\") {\n    client.on(\"NETWORK_RESPONSE\", async ({ payload }: any) => {\n      if (payload.url?.includes(\"backend-api\")) {\n        // console.log(\"NETWORK_RESPONSE\", payload.url, payload.body);\n        const body = JSON.parse(payload.body);\n        if (payload.url.includes(\"conversations\")) {\n          await db.addConversationItems(body.items);\n        } else if (payload.url.includes(\"conversation/\")) {\n          // alert(\"conversation found:  \" + payload.url);\n          const { pathname } = new URL(payload.url);\n          const id = pathname.split(\"/\").pop();\n          await db.createConversationStore(id as string, body);\n          // alert(\"scan for next update\");\n          const next = await db.scan();\n          // alert(\"scan complete\");\n          chrome.runtime.sendMessage(\n            {\n              action: \"stopInspectNetwork\",\n            },\n            () => {\n              // alert(\"stop inspect network\");\n              if (next) {\n                // alert(\"next update found\" + id + \" \" + next);\n                window.location.href = location.href.replace(\n                  id as string,\n                  next as string\n                );\n              } else {\n                alert(\"no more updates found\");\n                window.location.href = location.href.split(\"#\")[0];\n              }\n            }\n          );\n        }\n      }\n    });\n    const response = await new Promise((resolve) =>\n      chrome.runtime.sendMessage(\n        {\n          action: \"inspectNetwork\",\n        },\n        resolve\n      )\n    );\n  }\n})();\n"],"names":[],"sourceRoot":""}